{"data":{"site":{"siteMetadata":{"fullName":"olivia ifrim","settings":{"disqusShortName":"oliviaifrim"},"twitterHandle":"@oliviff"}},"markdownRemark":{"id":"b0c2d9eb-9e9c-53ac-bc12-5da297bbe5b8","html":"<p>This post is the start of a mini-series on <a href=\"https://en.wikipedia.org/wiki/Data_compression\">data compression</a>. Over the course of the series we will look at some algorithms for encoding, understand their strengths and weaknesses and we'll wrap up at the end with some wise thoughts after we've learnt all of this. </p>\n<p>First, what is data compression and why is it useful? </p>\n<p>Data compression is a way of encoding the raw information in a new format such that the resulting total byte size is smaller. The reason why this is useful is because we live in a world of huge images, videos, documents, etc. Watching a video on my phone requires a different resolution and quality than watching it on my 4K monitor, and encoding is one way to guarantee an experience customized to the device used but also the bandwidth constraints.   </p>\n<p>But you might wonder, how do we compress the data so that we don't lose any information? Well, sometimes we do sometimes we don't. The two big types of compression are: <strong>lossy</strong> and <strong>lossless</strong>. Generally lossy algorithms have some sort of heuristic which tells them how to discard the least important information. For example, the JPEG format uses a model based on the human visual system to tell it which information is least perceptible by the human eye, and thus can be discarded without any preceived loss of information. Lossless algorithms usually use interesting tricks to manipulate and store the data in a different format which minimizes duplication.</p>\n<p>Now that we understand a bit about data compression, let's got back to what this post is about, <a href=\"https://en.wikipedia.org/wiki/Run-length_encoding\">run length encoding</a>. This is one of the most basic compression schemes. In fact, you might have already implemented a run length encoder without knowing it!</p>\n<p>Let's see how it works.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">// This is our raw data, uncompressed.</span>\n<span class=\"token string\">\"aaaaaaabcdefff\"</span>\n\n<span class=\"token comment\">// The RLE is used to compress identical adjacent characters.</span>\n<span class=\"token string\">\"aaaaaaa\"</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token string\">\"a7\"</span>\n\n<span class=\"token comment\">// So then the whole compressed string would look like this.</span>\n<span class=\"token string\">\"a7b1c1d1e1f3\"</span> </code></pre></div>\n<p>So what we do is quite neat, instead of repeating ourselves, we just pack the adjacent identical characters. </p>\n<p>The code is pretty straight-forward.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token operator\">::</span>string RunLengthEncoder<span class=\"token operator\">::</span><span class=\"token function\">Encode</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> std<span class=\"token operator\">::</span>string<span class=\"token operator\">&amp;</span> data<span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span>\n<span class=\"token punctuation\">{</span>\n    std<span class=\"token operator\">::</span>stringstream stream<span class=\"token punctuation\">;</span>\n    size_t current <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    size_t length <span class=\"token operator\">=</span> data<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>current <span class=\"token operator\">&lt;</span> <span class=\"token punctuation\">(</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Loop while we have the same character</span>\n        size_t sequenceLength <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>current <span class=\"token operator\">&lt;</span> length <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> data<span class=\"token punctuation\">[</span>current<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> data<span class=\"token punctuation\">[</span>current <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token operator\">++</span>sequenceLength<span class=\"token punctuation\">;</span>\n            <span class=\"token operator\">++</span>current<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// Add to the encoded string</span>\n        stream <span class=\"token operator\">&lt;&lt;</span> data<span class=\"token punctuation\">[</span>current<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> sequenceLength<span class=\"token punctuation\">;</span>\n\n        <span class=\"token operator\">++</span>current<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> stream<span class=\"token punctuation\">.</span><span class=\"token function\">str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Now, pop quiz. Is RLE a lossy or lossless algorithm? Only counts if you do it without google.</p>\n<p>Next up, we'll pick a different encoding algorithm. </p>","excerpt":"This post is the start of a mini-series on  data compression . Over the course of the series we will look at some algorithms for encodingâ€¦","frontmatter":{"title":"Encoding - Run length encoder","date":"June 12, 2017","tags":["encoding","run length encoder","compression","data"],"featuredImage":{"childImageSharp":{"fluid":{"src":"/static/a04b5b19ea7683cc8df570ad041077da/5aa81/running.jpg","srcSet":"/static/a04b5b19ea7683cc8df570ad041077da/25db0/running.jpg 175w,\n/static/a04b5b19ea7683cc8df570ad041077da/62b24/running.jpg 350w,\n/static/a04b5b19ea7683cc8df570ad041077da/5aa81/running.jpg 700w","sizes":"(max-width: 700px) 100vw, 700px"}}}}}},"pageContext":{"slug":"/posts/6-run-length-encoder/","previous":{"fields":{"slug":"/posts/5-count-min-sketch/"},"frontmatter":{"title":"Count min sketch explained"}},"next":{"fields":{"slug":"/posts/7-gatsby-deploy-github/"},"frontmatter":{"title":"How to deploy a personal Gatsby site to Github pages"}}}}